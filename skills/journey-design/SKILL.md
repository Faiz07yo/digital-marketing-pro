---
name: journey-design
description: "Use when the user wants to design a cross-channel customer journey — define states, transitions, touchpoints, branching logic, timing, and content per stage with simulation before launch."
---

# /dm:journey-design

## Purpose

Design comprehensive cross-channel customer journeys as state machines. Define journey states (awareness through advocacy), transitions triggered by engagement signals, touchpoints with channel-specific content, branching logic for personalization, and simulate expected outcomes before launch. Turns abstract customer lifecycle stages into concrete, executable journey maps with specific content, timing, and channels at every step — then validates the design with Monte Carlo simulation before committing resources to implementation.

## Input Required

The user must provide (or will be prompted for):

- **Journey objective**: The primary goal this journey serves — acquisition (convert prospects to customers), onboarding (activate new customers to first value), retention (keep existing customers engaged and renewing), win-back (re-engage churned or lapsed customers), upsell (move customers to higher tiers or additional products), advocacy (turn satisfied customers into referrers and promoters), or a custom lifecycle stage
- **Target audience segments**: The specific audience segments entering this journey — defined by demographics, behavior, lifecycle stage, or prior engagement. Multiple segments supported with branching paths based on segment-specific behavior. E.g., "trial users who signed up from blog content", "enterprise accounts with 30+ seats approaching renewal", or "lapsed customers who churned in the last 90 days"
- **Available channels**: The communication channels available for touchpoints — email, SMS, social media (organic and paid), in-app messaging, push notifications, direct mail, sales outreach, ads (retargeting and prospecting), webinars, or community. Only channels the brand has operational capability for should be included
- **Desired outcomes**: Measurable success criteria for the journey — primary conversion goal (e.g., "60% of trial users reach activation within 7 days"), secondary metrics (engagement rate, time-to-convert, drop-off rate per stage), and guardrails (maximum touches per week, minimum time between messages, unsubscribe rate ceiling)
- **Content assets available**: Existing content that can be used or adapted for touchpoints — blog posts, case studies, product demos, email templates, landing pages, videos, webinars, or documentation. Also note any content gaps that will require new creation
- **Journey duration (optional)**: Expected total timeline from entry to completion — e.g., "14-day onboarding", "90-day retention cycle", "30-day win-back window". If omitted, the system designs based on objective-appropriate defaults
- **Personalization signals (optional)**: Behavioral or demographic signals available for branching — product usage data, email engagement history, website behavior, purchase history, support ticket status, or NPS score. More signals enable more sophisticated branching logic

## Process

1. **Load brand context**: Read `~/.claude-marketing/brands/_active-brand.json` for the active slug, then load `~/.claude-marketing/brands/{slug}/profile.json`. Apply brand voice, tone, compliance rules (`skills/context-engine/compliance-rules.md`), industry context, and audience personas to inform journey design. Load guidelines from `~/.claude-marketing/brands/{slug}/guidelines/_manifest.json` if present — apply channel restrictions, frequency caps, and content standards. Check for agency SOPs at `~/.claude-marketing/sops/`. If no brand exists, ask: "Set up a brand first (/dm:brand-setup)?" — or proceed with defaults.
2. **Design journey state machine**: Define the journey states based on the objective. Each state represents a distinct phase the customer passes through — e.g., for onboarding: Welcome (day 0-1), Activation (day 1-3), First Value (day 3-7), Habit Formation (day 7-14), Advocate (day 14+). For acquisition: Awareness, Interest, Consideration, Intent, Evaluation, Purchase. Each state has entry criteria, exit criteria, and a maximum dwell time before escalation or alternative path triggers.
3. **Define transitions**: For each state-to-state transition, specify the trigger event (what the customer does or doesn't do that causes movement), transition probability (estimated likelihood based on industry benchmarks and brand data), timing window (how long the customer typically stays in the current state before transitioning), and fallback behavior (what happens if the customer doesn't transition within the expected window — escalate, retry, or move to an alternative path).
4. **Map touchpoints**: For each transition, design the specific touchpoint — which channel delivers the message, the content brief (what the message communicates and what action it drives), timing relative to the trigger event (immediate, 1 hour delay, next morning, etc.), and success criteria (what constitutes engagement with this touchpoint). Each touchpoint references available content assets or flags a content gap requiring new creation.
5. **Design branching logic**: Create personalization branches based on available signals. Engagement-based branches split on whether the customer interacted with the previous touchpoint (opened email, clicked link, visited page). Behavioral branches split on product usage, purchase behavior, or website activity. Time-based branches handle customers who stall — shorter wait times for high-intent signals, longer nurture paths for low engagement. Each branch has its own touchpoint sequence and exit criteria.
6. **Simulate journey outcomes**: Execute `journey-engine.py simulate` with the designed state machine. Run Monte Carlo simulation (1,000+ iterations) to predict conversion rates at each stage, identify bottleneck states where customers stall or drop off, estimate total time-to-convert distribution, calculate expected touchpoint volume per channel, and project resource requirements. Compare simulated outcomes against the user's desired outcomes and flag gaps.
7. **Create content briefs**: For each touchpoint in the journey, generate a content brief — subject line or headline direction, key message and value proposition for that stage, call-to-action, tone and urgency level, personalization variables, and channel-specific formatting requirements. Reference existing content assets where available and flag gaps requiring new creation with priority level.
8. **Generate implementation checklist**: Break down the journey into platform-specific implementation tasks — email automation sequences to build, SMS triggers to configure, ad audience segments to create, in-app message rules to set up, sales handoff criteria to define, and tracking events to instrument. Organize by platform with dependencies noted so implementation can proceed in parallel where possible.

## Output

- **Journey state machine diagram**: Visual representation of all states, transitions, and branches — showing the complete customer path from entry to completion with transition probabilities, timing, and decision points clearly labeled
- **Touchpoint calendar**: Chronological map of every touchpoint in the journey — channel, timing relative to journey entry and trigger events, content summary, and success criteria. Organized by journey day and by channel for dual-view planning
- **Simulation results**: Monte Carlo simulation output showing predicted conversion rate at each stage with confidence intervals, identified bottleneck states with drop-off analysis, time-to-convert distribution (median, 25th percentile, 75th percentile), expected touchpoint volume per channel per month, and comparison against desired outcomes with gap analysis
- **Content briefs per touchpoint**: Complete content brief for each touchpoint — message direction, CTA, tone, personalization variables, channel formatting, and asset status (existing asset linked or new creation flagged with priority)
- **Implementation checklist per platform**: Task list organized by platform — email automation setup, SMS configuration, ad audience creation, in-app messaging rules, sales handoff triggers, and analytics tracking. Each task includes dependencies, estimated effort, and implementation order
- **Branching logic documentation**: Complete branching rules with trigger conditions, segment routing, and fallback behavior — formatted for implementation by marketing operations or automation platforms
- **Monitoring plan with success metrics**: KPIs to track at each journey stage, alert thresholds for underperformance, A/B test opportunities within the journey, and recommended optimization cadence (weekly review, monthly redesign)

## Agents Used

- **journey-orchestrator** — Journey architecture and state machine design with objective-appropriate state definitions, transition modeling with probability estimation and timing windows, branching logic design based on engagement, behavioral, and time-based signals, Monte Carlo simulation execution and outcome analysis, touchpoint planning with channel-timing-content mapping, implementation checklist generation per platform, and monitoring plan design with stage-level KPIs and alert thresholds
- **content-creator** — Touchpoint content brief generation with stage-appropriate messaging, tone calibration across journey phases (welcoming in early states, urgency in stall states, celebratory in success states), personalization variable mapping, and content gap identification with creation priority assignment
- **email-specialist** — Email sequence integration within the broader journey, email-specific touchpoint optimization (subject lines, send timing, frequency management), deliverability considerations for high-volume automated sequences, and email branching logic based on open, click, and reply engagement signals
